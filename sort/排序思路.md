# 排序思路
## 1. 时间复杂度O(n*n)
冒泡排序:
- 给出一个数组arr=[5,8,68,4,7,25,86,34]对他从小到大排序
- 思路：
    1. 遍历数组，找出最大值放在数组最右边
    2. 除去最大值，把剩下的数字 看做一个新数组
    3. 遍历新数组，找出最大值放在新数组最右边
    4. 重复第二步和第三步，直到数组里只剩一个数
    5. 排序结束，返回数组arr。
- [冒泡排序链接](https://github.com/xingxiaodong1994/blog/blob/master/sort/bubble.html)   
## 2. 时间复杂度O(n log2 n)
快排：
- 给出一个数组arr=[5,8,68,4,7,25,86,34]对他从小到大排序
- 思路：
    1. 取arr[0]作为基准，遍历数组，把大于arr[0]的放入数组的右边，把小于arr[0]的放入一个数组的左边。
    2. 把数组的右边看做一个新数组，取新数组[0]作为基准， 遍历数组，把大于新数组 [0]的放入一个新数组的右边 ，把小于新数组[0]的放入一个新数组的左边。
    3. 把数组的左边边看做一个新数组，取新数组[0]作为基准， 遍历数组，把大于新数组 [0]的放入一个新数组的右边 ，把小于新数组[0]的放入一个新数组的左边。
    4. 重复第二步和第三步，直到新数组里只剩一个数。
    5. 排序结束，返回数组arr。
- [快排链接](https://github.com/xingxiaodong1994/blog/blob/master/sort/quick.html) 
## 3. 时间复杂度O(n+max)
计数排序：
- 给出一个数组arr=[5,8,68,4,7,25,86,34]对他从小到大排序
- 思路：
    1. 遍历数组，找出数组最大值arr[max]。
    2. 定义一个对象hash{},hash.lenght=arr[max];hash{0,0,0,0,...}哈希中每一项初始值都为0；
    3. 再次遍历数组，数组中的每一项的值作为哈希的下标，每遍历数组中的一项，其对应下标的哈希项的值自增1.
    4. 遍历哈希数组，把哈希的下标push进新数组arr1，此下标对应哈希的值为n，就push n个下标进入新数组
    5.  排序结束，返回新数组数组arr1.
- [计数排序链接](https://github.com/xingxiaodong1994/blog/blob/master/sort/count.html) 